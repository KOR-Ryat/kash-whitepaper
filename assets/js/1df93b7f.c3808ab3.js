"use strict";(self.webpackChunkkash_whitepaper=self.webpackChunkkash_whitepaper||[]).push([[4583],{2678:(e,r,t)=>{t.r(r),t.d(r,{default:()=>R});var n=t(797),o=t(1410);const a={heroSection:"heroSection_aWOV",heroTitle:"heroTitle_qg2I",heroCatchphrase:"heroCatchphrase_tQqR",heroButton:"heroButton_GTT_"};var i=t(6540);const s="fallingCoinsCanvas_pClv";var l=t(4848);const f=(e,r,t)=>({x:e||0,y:r||0,z:t||0}),u=(e,r,t)=>{e.x=r.y*t.z-r.z*t.y,e.y=r.z*t.x-r.x*t.z,e.z=r.x*t.y-r.y*t.x},c=e=>{let r=e.x*e.x+e.y*e.y+e.z*e.z;r>1e-5&&(r=1/Math.sqrt(r),e.x*=r,e.y*=r,e.z*=r)},d=e=>(e.array?(e.array[0]=e.x,e.array[1]=e.y,e.array[2]=e.z):e.array=new Float32Array([e.x,e.y,e.z]),e.array),m=()=>new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),h=(e,r,t,n,o)=>{const a=n*Math.tan(t*Math.PI/180*.5)*2,i=a*r;e[0]=2*n/i,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*n/a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=-(o+n)/(o-n),e[11]=-1,e[12]=0,e[13]=0,e[14]=-2*o*n/(o-n),e[15]=0},p=(e,r,t,n)=>{const o=f(r.x-t.x,r.y-t.y,r.z-t.z);c(o);const a=f(1,0,0);u(a,n,o),c(a);const i=f(1,0,0);u(i,o,a),c(i),e[0]=a.x,e[1]=i.x,e[2]=o.x,e[3]=0,e[4]=a.y,e[5]=i.y,e[6]=o.y,e[7]=0,e[8]=a.z,e[9]=i.z,e[10]=o.z,e[11]=0,e[12]=-(r.x*e[0]+r.y*e[4]+r.z*e[8]),e[13]=-(r.x*e[1]+r.y*e[5]+r.z*e[9]),e[14]=-(r.x*e[2]+r.y*e[6]+r.z*e[10]),e[15]=1},v="\nuniform vec3 uResolution;\nattribute vec2 aPosition;\nvarying vec2 texCoord;\nvarying vec2 screenCoord;\nvoid main(void) {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n    texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5);\n    screenCoord = aPosition.xy * vec2(uResolution.z, 1.0);\n}";class y{constructor(){this.velocity=[0,0,0],this.rotation=[0,0,0],this.position=[0,0,0],this.euler=[0,0,0],this.size=1,this.alpha=1,this.zkey=0}setVelocity(e,r,t){this.velocity[0]=e,this.velocity[1]=r,this.velocity[2]=t}setRotation(e,r,t){this.rotation[0]=e,this.rotation[1]=r,this.rotation[2]=t}setPosition(e,r,t){this.position[0]=e,this.position[1]=r,this.position[2]=t}setEulerAngles(e,r,t){this.euler[0]=e,this.euler[1]=r,this.euler[2]=t}setSize(e){this.size=e}update(e,r){this.position[0]+=this.velocity[0]*e,this.position[1]+=this.velocity[1]*e,this.position[2]+=this.velocity[2]*e,this.euler[0]+=this.rotation[0]*e,this.euler[1]+=this.rotation[1]*e,this.euler[2]+=this.rotation[2]*e}}const g=()=>{const e=(0,i.useRef)(null),r=(0,i.useRef)(null),t=(0,i.useRef)({start:0,prev:0,delta:0,elapsed:0}),n=(0,i.useRef)({width:0,height:0,aspect:1,array:new Float32Array(3),halfWidth:0,halfHeight:0,halfArray:new Float32Array(3),pointSize:{min:0,max:0}}),o=(0,i.useRef)({angle:60,nearfar:new Float32Array([.1,100]),matrix:m()}),a=(0,i.useRef)({position:f(0,0,100),lookat:f(0,0,0),up:f(0,1,0),dof:f(10,4,8),matrix:m()}),u=(0,i.useRef)({program:null,particles:[],dataArray:null,buffer:null,offset:new Float32Array([0,0,0]),fader:f(0,10,0),numCoins:1600,positionArrayOffset:0,eulerArrayOffset:0,miscArrayOffset:0,area:f(20,20,20)}),g=(0,i.useRef)({}),R=(0,i.useRef)(!1),E=(0,i.useRef)(),x=(0,i.useRef)(!0);return(0,i.useEffect)((()=>{const i=e.current;if(!i)return;try{r.current=i.getContext("experimental-webgl")}catch(U){return console.error("WebGL not supported.",U),void alert("WebGL not supported.")}const s=r.current;if(!s)return void alert("Failed to get WebGL context.");const l=e=>{s&&e&&(s.deleteFramebuffer(e.frameBuffer),s.deleteRenderbuffer(e.renderBuffer),s.deleteTexture(e.texture))},m=(e,r)=>{const t=s.createShader(e);return s.shaderSource(t,r),s.compileShader(t),s.getShaderParameter(t,s.COMPILE_STATUS)?t:(console.error(s.getShaderInfoLog(t)),s.deleteShader(t),null)},T=(e,r,t,n)=>{const o=m(s.VERTEX_SHADER,e),a=m(s.FRAGMENT_SHADER,r);if(!o||!a)return null;const i=s.createProgram();return s.attachShader(i,o),s.attachShader(i,a),s.deleteShader(o),s.deleteShader(a),s.linkProgram(i),s.getProgramParameter(i,s.LINK_STATUS)?(t&&(i.uniforms={},t.forEach((e=>i.uniforms[e]=s.getUniformLocation(i,e)))),n&&(i.attributes={},n.forEach((e=>i.attributes[e]=s.getAttribLocation(i,e)))),i):(console.error(s.getProgramInfoLog(i)),null)},A=e=>{if(s.useProgram(e),e.attributes)for(const r in e.attributes)s.enableVertexAttribArray(e.attributes[r])},F=e=>{if(e.attributes)for(const r in e.attributes)s.disableVertexAttribArray(e.attributes[r]);s.useProgram(null)},b=(e,r,t,n)=>{const o=["uResolution","uSrc","uDelta"].concat(t||[]),a=["aPosition"].concat(n||[]),i=T(e,r,o,a);if(!i)return null;const l={program:i};return l.dataArray=new Float32Array([-1,-1,1,-1,-1,1,1,1]),l.buffer=s.createBuffer(),s.bindBuffer(s.ARRAY_BUFFER,l.buffer),s.bufferData(s.ARRAY_BUFFER,l.dataArray,s.STATIC_DRAW),s.bindBuffer(s.ARRAY_BUFFER,null),l},_=(e,r)=>{const t=n.current,o=e.program;A(o),s.uniform3fv(o.uniforms.uResolution,t.array),r&&(s.uniform2fv(o.uniforms.uDelta,r.dtxArray),s.uniform1i(o.uniforms.uSrc,0),s.activeTexture(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,r.texture))},B=e=>{s.bindBuffer(s.ARRAY_BUFFER,e.buffer),s.vertexAttribPointer(e.program.attributes.aPosition,2,s.FLOAT,!1,0,0),s.drawArrays(s.TRIANGLE_STRIP,0,4)},C=e=>{F(e.program)},D=()=>{const e=n.current,r=o.current,t=a.current,i=u.current;(()=>{const e=n.current,r=u.current;r.area=f(20,20,20),r.area.x=r.area.y*e.aspect,r.fader.x=10,r.fader.y=r.area.z,r.fader.z=.1;const t=2*Math.PI,o=()=>2*Math.random()-1;for(let n=0;n<r.numCoins;n++){const e=r.particles[n],a=f(.3*o()+.8,.2*o()-1,.3*o()+.5);c(a);const i=2+1*Math.random();e.setVelocity(a.x*i,a.y*i,a.z*i),e.setRotation(o()*t*.5,o()*t*.5,o()*t*.5),e.setPosition(o()*r.area.x,o()*r.area.y,o()*r.area.z),e.setEulerAngles(Math.random()*t,Math.random()*t,Math.random()*t),e.setSize(.9+.1*Math.random())}})(),t.position.z=i.area.z+r.nearfar[0],r.angle=180*Math.atan2(i.area.y,t.position.z+i.area.z)/Math.PI*2,h(r.matrix,e.aspect,r.angle,r.nearfar[0],r.nearfar[1])},w=()=>{const e=a.current,r=n.current;p(e.matrix,e.position,e.lookat,e.up),s.enable(s.DEPTH_TEST),s.bindFramebuffer(s.FRAMEBUFFER,r.mainRT.frameBuffer),s.viewport(0,0,r.mainRT.width,r.mainRT.height),s.clearColor(.005,0,.05,0),s.clear(s.COLOR_BUFFER_BIT|s.DEPTH_BUFFER_BIT),(()=>{const e=t.current,r=g.current;s.disable(s.DEPTH_TEST),_(r.sceneBg,null),s.uniform2f(r.sceneBg.program.uniforms.uTimes,e.elapsed,e.delta),B(r.sceneBg),C(r.sceneBg),s.enable(s.DEPTH_TEST)})(),(()=>{const e=t.current,r=a.current,i=u.current,l=o.current,f=n.current,c=2*Math.PI,m=(e,r,t)=>{Math.abs(e.position[r])-.5*e.size>t&&(e.position[r]=e.position[r]>0?e.position[r]-2*t:e.position[r]+2*t)},h=(e,r)=>{e.euler[r]=e.euler[r]%c,e.euler[r]<0&&(e.euler[r]+=c)};i.particles.forEach((t=>{t.update(e.delta,e.elapsed),m(t,0,i.area.x),m(t,1,i.area.y),m(t,2,i.area.z),h(t,0),h(t,1),h(t,2),t.alpha=1,t.zkey=r.matrix[2]*t.position[0]+r.matrix[6]*t.position[1]+r.matrix[10]*t.position[2]+r.matrix[14]})),i.particles.sort(((e,r)=>e.zkey-r.zkey));let p=i.positionArrayOffset,v=i.eulerArrayOffset,y=i.miscArrayOffset;i.particles.forEach((e=>{i.dataArray[p++]=e.position[0],i.dataArray[p++]=e.position[1],i.dataArray[p++]=e.position[2],i.dataArray[v++]=e.euler[0],i.dataArray[v++]=e.euler[1],i.dataArray[v++]=e.euler[2],i.dataArray[y++]=e.size,i.dataArray[y++]=e.alpha})),s.enable(s.BLEND),s.blendFunc(s.SRC_ALPHA,s.ONE_MINUS_SRC_ALPHA);const g=i.program;A(g),s.uniformMatrix4fv(g.uniforms.uProjection,!1,l.matrix),s.uniformMatrix4fv(g.uniforms.uModelview,!1,r.matrix),s.uniform3fv(g.uniforms.uResolution,f.array),s.uniform3fv(g.uniforms.uDOF,d(r.dof)),s.uniform3fv(g.uniforms.uFade,d(i.fader)),s.bindBuffer(s.ARRAY_BUFFER,i.buffer),s.bufferSubData(s.ARRAY_BUFFER,0,i.dataArray);const R=Float32Array.BYTES_PER_ELEMENT;s.vertexAttribPointer(g.attributes.aPosition,3,s.FLOAT,!1,0,i.positionArrayOffset*R),s.vertexAttribPointer(g.attributes.aEuler,3,s.FLOAT,!1,0,i.eulerArrayOffset*R),s.vertexAttribPointer(g.attributes.aMisc,2,s.FLOAT,!1,0,i.miscArrayOffset*R);for(let t=1;t<2;t++){const e=-2*t;i.offset[0]=-1*i.area.x,i.offset[1]=-1*i.area.y,i.offset[2]=i.area.z*e,s.uniform3fv(g.uniforms.uOffset,i.offset),s.drawArrays(s.POINT,0,i.numCoins),i.offset[0]=-1*i.area.x,i.offset[1]=1*i.area.y,i.offset[2]=i.area.z*e,s.uniform3fv(g.uniforms.uOffset,i.offset),s.drawArrays(s.POINT,0,i.numCoins),i.offset[0]=1*i.area.x,i.offset[1]=-1*i.area.y,i.offset[2]=i.area.z*e,s.uniform3fv(g.uniforms.uOffset,i.offset),s.drawArrays(s.POINT,0,i.numCoins),i.offset[0]=1*i.area.x,i.offset[1]=1*i.area.y,i.offset[2]=i.area.z*e,s.uniform3fv(g.uniforms.uOffset,i.offset),s.drawArrays(s.POINT,0,i.numCoins)}i.offset[0]=0,i.offset[1]=0,i.offset[2]=0,s.uniform3fv(g.uniforms.uOffset,i.offset),s.drawArrays(s.POINT,0,i.numCoins),s.bindBuffer(s.ARRAY_BUFFER,null),F(g),s.enable(s.DEPTH_TEST),s.disable(s.BLEND)})(),(()=>{const e=n.current,r=g.current;s.enable(s.TEXTURE_2D),s.disable(s.DEPTH_TEST);const t=(e,r)=>{s.bindFramebuffer(s.FRAMEBUFFER,e.frameBuffer),s.viewport(0,0,e.width,e.height),r&&(s.clearColor(0,0,0,0),s.clear(s.COLOR_BUFFER_BIT|s.DEPTH_BUFFER_BIT))};t(e.wHalfRT0,!0),_(r.mkBrightBuf,e.mainRT),B(r.mkBrightBuf),C(r.mkBrightBuf);for(let n=0;n<2;n++){const o=1.5+1*n,a=2+1*n;t(e.wHalfRT1,!0),_(r.dirBlur,e.wHalfRT0),s.uniform4f(r.dirBlur.program.uniforms.uBlurDir,o,0,a,0),B(r.dirBlur),C(r.dirBlur),t(e.wHalfRT0,!0),_(r.dirBlur,e.wHalfRT1),s.uniform4f(r.dirBlur.program.uniforms.uBlurDir,0,o,0,a),B(r.dirBlur),C(r.dirBlur)}s.bindFramebuffer(s.FRAMEBUFFER,null),s.viewport(0,0,e.width,e.height),s.clear(s.COLOR_BUFFER_BIT|s.DEPTH_BUFFER_BIT),_(r.finalComp,e.mainRT),s.uniform1i(r.finalComp.program.uniforms.uBloom,1),s.activeTexture(s.TEXTURE1),s.bindTexture(s.TEXTURE_2D,e.wHalfRT0.texture),B(r.finalComp),C(r.finalComp),s.enable(s.DEPTH_TEST)})()},z=()=>{const e=n.current;(e=>{const r=e.parentElement;r&&r!==document.body?(e.width=r.clientWidth,e.height=r.clientHeight):(e.width=window.innerWidth,e.height=window.innerHeight)})(i),e.setSize=(r,t)=>{e.width=r,e.height=t,e.aspect=r/t,e.array[0]=r,e.array[1]=t,e.array[2]=e.aspect,e.halfWidth=Math.floor(r/2),e.halfHeight=Math.floor(t/2),e.halfArray[0]=e.halfWidth,e.halfArray[1]=e.halfHeight,e.halfArray[2]=e.halfWidth/e.halfHeight},e.setSize(i.width,i.height),s.viewport(0,0,e.width,e.height);const r=(r,t,n)=>{e[r]&&l(e[r]),e[r]=((e,r)=>{const t={width:e,height:r,sizeArray:new Float32Array([e,r,e/r]),dtxArray:new Float32Array([1/e,1/r])};return t.frameBuffer=s.createFramebuffer(),t.renderBuffer=s.createRenderbuffer(),t.texture=s.createTexture(),s.bindTexture(s.TEXTURE_2D,t.texture),s.texImage2D(s.TEXTURE_2D,0,s.RGBA,e,r,0,s.RGBA,s.UNSIGNED_BYTE,null),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MAG_FILTER,s.LINEAR),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MIN_FILTER,s.LINEAR),s.bindFramebuffer(s.FRAMEBUFFER,t.frameBuffer),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,t.texture,0),s.bindRenderbuffer(s.RENDERBUFFER,t.renderBuffer),s.renderbufferStorage(s.RENDERBUFFER,s.DEPTH_COMPONENT16,e,r),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.DEPTH_ATTACHMENT,s.RENDERBUFFER,t.renderBuffer),s.bindTexture(s.TEXTURE_2D,null),s.bindRenderbuffer(s.RENDERBUFFER,null),s.bindFramebuffer(s.FRAMEBUFFER,null),t})(t,n)};r("mainRT",e.width,e.height),r("wHalfRT0",e.halfWidth,e.halfHeight),r("wHalfRT1",e.halfWidth,e.halfHeight)},P=()=>{const e=t.current,r=Date.now();e.elapsed=(r-e.start)/1e3,e.delta=(r-e.prev)/1e3,e.prev=r,x.current&&(E.current=requestAnimationFrame(P)),w()},O=()=>{z(),R.current&&D()};z(),(()=>{const e=g.current;e.sceneBg=b(v,"\n#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 uTimes;\nvarying vec2 texCoord;\nvarying vec2 screenCoord;\nvoid main(void) {\n    vec3 col;\n    float c;\n    vec2 tmpv = texCoord * vec2(0.8, 1.0) - vec2(0.95, 1.0);\n    c = exp(-pow(length(tmpv) * 1.8, 2.0));\n    col = mix(vec3(0.02, 0.0, 0.03), vec3(0.96, 0.98, 1.0) * 1.5, c);\n    gl_FragColor = vec4(col * 0.5, 1.0);\n}",["uTimes"]),e.mkBrightBuf=b(v,"\n#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D uSrc;\nuniform vec2 uDelta;\nvarying vec2 texCoord;\nvarying vec2 screenCoord;\nvoid main(void) {\n    vec4 col = texture2D(uSrc, texCoord);\n    gl_FragColor = vec4(col.rgb * 2.0 - vec3(0.5), 1.0);\n}"),e.dirBlur=b(v,"\n#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D uSrc;\nuniform vec2 uDelta;\nuniform vec4 uBlurDir; //dir(x, y), stride(z, w)\nvarying vec2 texCoord;\nvarying vec2 screenCoord;\nvoid main(void) {\n    vec4 col = texture2D(uSrc, texCoord);\n    col = col + texture2D(uSrc, texCoord + uBlurDir.xy * uDelta);\n    col = col + texture2D(uSrc, texCoord - uBlurDir.xy * uDelta);\n    col = col + texture2D(uSrc, texCoord + (uBlurDir.xy + uBlurDir.zw) * uDelta);\n    col = col + texture2D(uSrc, texCoord - (uBlurDir.xy + uBlurDir.zw) * uDelta);\n    gl_FragColor = col / 5.0;\n}",["uBlurDir"]),e.finalComp=b(v,"\n#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D uSrc;\nuniform sampler2D uBloom;\nuniform vec2 uDelta;\nvarying vec2 texCoord;\nvarying vec2 screenCoord;\nvoid main(void) {\n    vec4 srccol = texture2D(uSrc, texCoord) * 2.0;\n    vec4 bloomcol = texture2D(uBloom, texCoord);\n    vec4 col;\n    col = srccol + bloomcol * (vec4(1.0) + srccol);\n    col *= smoothstep(1.0, 0.0, pow(length((texCoord - vec2(0.5)) * 2.0), 1.2) * 0.5);\n    col = pow(col, vec4(0.45454545454545)); //(1.0 / 2.2)\n    gl_FragColor = vec4(col.rgb, 1.0);\n    gl_FragColor.a = 1.0;\n}",["uBloom"]),Object.values(e).some((e=>null===e))&&console.error("Failed to create one or more effect programs.")})(),(()=>{const e=n.current,r=u.current,t=s.getParameter(s.ALIASED_POINT_SIZE_RANGE);if(e.pointSize={min:t[0],max:t[1]},r.program=T("\nuniform mat4 uProjection;\nuniform mat4 uModelview;\nuniform vec3 uResolution;\nuniform vec3 uOffset;\nuniform vec3 uDOF;  //x:focus distance, y:focus radius, z:max radius\nuniform vec3 uFade; //x:start distance, y:half distance, z:near fade start\n\nattribute vec3 aPosition;\nattribute vec3 aEuler;\nattribute vec2 aMisc; //x:size, y:fade\n\nvarying vec3 pposition;\nvarying float psize;\nvarying float palpha;\nvarying float pdist;\n\nvarying vec3 normX;\nvarying vec3 normY;\nvarying vec3 normZ;\nvarying vec3 normal;\n\nvarying float diffuse;\nvarying float specular;\nvarying float rstop;\nvarying float distancefade;\n\nvoid main(void) {\n    vec4 pos = uModelview * vec4(aPosition + uOffset, 1.0);\n    gl_Position = uProjection * pos;\n    gl_PointSize = aMisc.x * uProjection[1][1] / -pos.z * uResolution.y * 0.5;\n    \n    pposition = pos.xyz;\n    psize = aMisc.x;\n    pdist = length(pos.xyz);\n    palpha = smoothstep(0.0, 1.0, (pdist - 0.1) / uFade.z);\n    \n    vec3 elrsn = sin(aEuler);\n    vec3 elrcs = cos(aEuler);\n    mat3 rotx = mat3(\n        1.0, 0.0, 0.0,\n        0.0, elrcs.x, elrsn.x,\n        0.0, -elrsn.x, elrcs.x\n    );\n    mat3 roty = mat3(\n        elrcs.y, 0.0, -elrsn.y,\n        0.0, 1.0, 0.0,\n        elrsn.y, 0.0, elrcs.y\n    );\n    mat3 rotz = mat3(\n        elrcs.z, elrsn.z, 0.0, \n        -elrsn.z, elrcs.z, 0.0,\n        0.0, 0.0, 1.0\n    );\n    mat3 rotmat = rotx * roty * rotz;\n    normal = rotmat[2];\n    \n    mat3 trrotm = mat3(\n        rotmat[0][0], rotmat[1][0], rotmat[2][0],\n        rotmat[0][1], rotmat[1][1], rotmat[2][1],\n        rotmat[0][2], rotmat[1][2], rotmat[2][2]\n    );\n    normX = trrotm[0];\n    normY = trrotm[1];\n    normZ = trrotm[2];\n    \n    const vec3 lit = vec3(0.6917144638660746, 0.6917144638660746, -0.20751433915982237);\n    \n    float tmpdfs = dot(lit, normal);\n    if(tmpdfs < 0.0) {\n        normal = -normal;\n        tmpdfs = dot(lit, normal);\n    }\n    diffuse = 0.4 + tmpdfs;\n    \n    vec3 eyev = normalize(-pos.xyz);\n    if(dot(eyev, normal) > 0.0) {\n        vec3 hv = normalize(eyev + lit);\n        specular = pow(max(dot(hv, normal), 0.0), 20.0);\n    }\n    else {\n        specular = 0.0;\n    }\n    \n    rstop = clamp((abs(pdist - uDOF.x) - uDOF.y) / uDOF.z, 0.0, 1.0);\n    rstop = pow(rstop, 0.5);\n    distancefade = min(1.0, exp((uFade.x - pdist) * 0.69315 / uFade.y));\n}","\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform vec3 uDOF;\nuniform vec3 uFade;\n\nconst vec3 fadeCol = vec3(0.08, 0.03, 0.06); // Background fade color from original\n\nvarying vec3 pposition;\nvarying float psize;\nvarying float palpha;\nvarying float pdist;\n\nvarying vec3 normX;\nvarying vec3 normY;\nvarying vec3 normZ;\nvarying vec3 normal;\n\nvarying float diffuse;\nvarying float specular;\nvarying float rstop;\nvarying float distancefade;\n\nvoid main(void) {\n    vec3 p = vec3(gl_PointCoord - vec2(0.5, 0.5), 0.0) * 2.0;\n    vec3 d = vec3(0.0, 0.0, -1.0);\n    float nd = normZ.z;\n    if(abs(nd) < 0.0001) discard;\n    \n    float np = dot(normZ, p);\n    vec3 tp = p + d * np / nd;\n    vec2 coord = vec2(dot(normX, tp), dot(normY, tp));\n    \n    // --- MODIFICATION FOR COIN SHAPE ---\n    float coin_r = length(coord); // Distance from center for a circle\n    \n    if(coin_r > rstop) discard; // Use rstop for DOF, makes circle edge soft based on focus\n    if(coin_r > 1.0) discard; // Ensure it's a circle within the point sprite\n\n    // --- MODIFICATION FOR COIN COLOR ---\n    // Gold color (e.g., R=255, G=215, B=0 -> normalized: 1.0, 0.843, 0.0)\n    // Let's use a slightly brighter yellow-gold: vec3(1.0, 0.87, 0.2)\n    vec3 baseCoinColor = vec3(1.0, 0.87, 0.2); \n\n    // Add subtle shading to give it a bit of a 3D feel\n    // Darken edges slightly, highlight center\n    float edge_darken = smoothstep(0.7, 1.0, coin_r);\n    vec3 shadedCoinColor = mix(baseCoinColor, baseCoinColor * 0.7, edge_darken);\n    \n    vec3 col = shadedCoinColor;\n    col = col * diffuse + specular * vec3(1.0, 1.0, 0.8); // Apply lighting, specular can be whitish-yellow\n\n    col = mix(fadeCol, col, distancefade); // Mix with background fade color\n    \n    float alpha = (rstop > 0.001)? (0.99975 - coin_r / (rstop * 2.0)) : 1.0;\n    alpha = smoothstep(0.0, 1.0, alpha) * palpha;\n    \n    // Original shader multiplied color by 0.5. Let's keep it for consistency with bloom.\n    gl_FragColor = vec4(col * 2.0, alpha); \n}",["uProjection","uModelview","uResolution","uOffset","uDOF","uFade"],["aPosition","aEuler","aMisc"]),r.program){A(r.program),r.particles=new Array(r.numCoins),r.dataArray=new Float32Array(8*r.numCoins),r.positionArrayOffset=0,r.eulerArrayOffset=3*r.numCoins,r.miscArrayOffset=6*r.numCoins,r.buffer=s.createBuffer(),s.bindBuffer(s.ARRAY_BUFFER,r.buffer),s.bufferData(s.ARRAY_BUFFER,r.dataArray,s.DYNAMIC_DRAW),s.bindBuffer(s.ARRAY_BUFFER,null),F(r.program);for(let e=0;e<r.numCoins;e++)r.particles[e]=new y}else console.error("Failed to create coin shader program")})(),R.current=!0,D();const S=t.current;return S.start=Date.now(),S.prev=S.start,x.current=!0,P(),window.addEventListener("resize",O),()=>{x.current=!1,E.current&&cancelAnimationFrame(E.current),window.removeEventListener("resize",O);const e=n.current;e.mainRT&&l(e.mainRT),e.wHalfRT0&&l(e.wHalfRT0),e.wHalfRT1&&l(e.wHalfRT1);const t=u.current;t.buffer&&s.deleteBuffer(t.buffer),t.program&&s.deleteProgram(t.program);const o=g.current;Object.values(o).forEach((e=>{e.buffer&&s.deleteBuffer(e.buffer),e.program&&s.deleteProgram(e.program)})),r.current=null}}),[]),(0,l.jsx)("canvas",{ref:e,className:s})};function R(){const{siteConfig:e}=(0,n.A)();return(0,l.jsx)(l.Fragment,{children:(0,l.jsxs)(o.A,{title:`Hello from ${e.title}`,description:"Description will go into a meta tag in <head />",children:[(0,l.jsx)("main",{children:(0,l.jsxs)("div",{className:a.heroSection,children:[(0,l.jsx)("h1",{className:a.heroTitle,children:"Project KASH"}),(0,l.jsx)("p",{className:a.heroCatchphrase,children:"Some catchphrase Some catchphrase Some catchphrase"}),(0,l.jsx)("a",{href:"/intro",rel:"noopener noreferrer",className:a.heroButton,children:"Whitepaper"})]})}),(0,l.jsx)(g,{})]})})}}}]);